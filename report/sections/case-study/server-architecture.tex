\subsection{Server Architecture} \label{subsect:case-study:arch:server}

The \mlblinkapi runs in its own server using \ubuntu and it is written in \python. It closely follows the Representational State Transfer (\rest) software architecture, where applications provide consistent interface semantics (usually create, read, update, and delete for each resource) rather than arbitrary interfaces. Additionally, the \rest interactions are ``stateless'' in the sense that a response provided by an application is dependent on the parameters it receives, not in the current state of it \cite{web:w3:rest}. \newline

To aid in the design of a \rest application, the \mlblinkapi is build on top of the Flask microframework \cite{software:flask}, which provides useful methods and abstractions to create web services that follow \rest conventions with minimal effort. The \mlblinkapi is served using the Apache HTTP Server in conjunction with \texttt{mod\_wsgi}; an Apache HTTP Server module that enables Apache to serve Flask applications. \newline

The majority of the data produced by the \mlblinkui usually consists of a structure of nested objects, as a result MongoDB was selected for persisting data in the \mlblinkapi. Additionally, since the UI uses Asynchronous JavaScript and XML (AJAX) requests to communicate with the server, the \mlblinkapi defines Cross--Origin Resource Sharing (CORS) rules to restrict that only the domain in which the \mlblinkui is being served from can access the server's resources; such as when retrieving a mission setup, or creating a mission along with its achieved accuracy and other attributes. \newline

Finally, the \mlblinkapi uses the Celery distributed task queue \cite{software:celery} with Redis \cite{software:redis} as a message broker in order to execute time--consuming tasks in the background without blocking the API. The Celery distributed task queue was also selected as it comes with an API that allows to execute background tasks concurrently on multiple processors.