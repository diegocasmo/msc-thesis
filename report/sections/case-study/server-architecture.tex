\subsubsection{Server Architecture} \label{subsubsect:case-study:arch:server}

The \mlblinkapi runs in its own server using \ubuntu and it is written in \python. It closely follows the Representational State Transfer (\rest) software architecture, where applications provide consistent interface semantics (usually create, read, update, and delete for each resource) rather than arbitrary interfaces. Additionally, the \rest interactions are ``stateless'' in the sense that a response provided by an application is dependent on the parameters it receives, not in the current state of it \cite{web:w3:rest}.

To aid in the design of a \rest application, the \mlblinkapi is build on top of the Flask microframework \cite{software:flask}, which provides useful methods and abstractions to create web services that follow \rest conventions with minimal effort. The \mlblinkapi is served using the Apache HTTP Server in conjunction with \texttt{mod\_wsgi}; an an Apache HTTP Server ``mod'' that enables Apache to serve Flask applications.

Since the data produced by the \mlblinkui usually consists of a structure of nested objects, the \mlblinkapi persists data using the MongoDB database. 

Finally, the \mlblinkapi uses the Celery distributed task queue \cite{software:celery} with Redis as a message broker in order to execute time--consuming tasks in the background without blocking the API. The Celery distributed task queue was also selected as it comes with an API that allows to execute tasks concurrently on multiple processors.